# This is a GitHub Actions workflow file
# Workflows are defined in YAML files in your repository's .github/workflows/ directory

# Required: Name of the workflow (displayed in the Actions tab)
name: Learn GitHub Actions

# Optional: Description of what this workflow does
run-name: Learning GitHub Actions workflow triggered by ${{ github.actor }}

# Required: Events that trigger the workflow
on:
  # Trigger on push to main branch
  push:
    branches: [main]

  # Trigger on pull requests to main
  pull_request:
    branches: [main]

  # Trigger manually from the GitHub UI
  workflow_dispatch:

  # Trigger on a schedule (cron syntax)
  schedule:
    - cron: "0 0 * * *" # Daily at midnight UTC

# Environment variables available to all jobs
env:
  NODE_VERSION: "18"
  PYTHON_VERSION: "3.9"

# Use permissions to modify the default permissions granted to the GITHUB_TOKEN

# Permissions define what the GITHUB_TOKEN can do
permissions: write-all # write-all|read-all or disable with {}
  # actions: read|write|none
  # attestations: read|write|none
  # checks: read|write|none
  # contents: read|write|none
  # deployments: read|write|none
  # id-token: write|none
  # issues: read|write|none
  # models: read|none
  # discussions: read|write|none
  # packages: read|write|none
  # pages: read|write|none
  # pull-requests: read|write|none
  # security-events: read|write|none
  # statuses: read|write|none

# provide default shell and working-directory options for all run steps
defaults:
  run:
    shell: bash
    working-directory: ./scripts

# Concurrency allows you to control the concurrency of workflow runs.
concurrency:
  # The concurrency key is used to group workflows or jobs together into a concurrency group.
  group: ci-${{ github.ref }}
  # Cancel any in-progress job or run
  cancel-in-progress: true

# Jobs are the core building blocks of workflows
# All jobs run in parallel by default, each job is a new clean runner environment
jobs:
  # Job ID (can be referenced by other jobs)
  basic-job:
    # Human-readable name for the job
    name: Basic Job Example

    # The type of runner to use
    runs-on: ubuntu-latest

    # Job level environment variables
    env:
      JOB_ENV: "development"

    # Conditionally run this job
    if: 1 == 1
    
    # Outputs from this job can be used by other jobs
    outputs:
      example-output: "Hello, World!"

    # List of steps to execute
    steps:
      # GitHub Actions are called with the uses keyword
      - uses: sormuras/hello-world-java-action@v1
        # Steps can have names for better readability
        name: My first step
        with:
          # Inputs are parameters passed to the action
          who-to-greet: 'Mona the Octocat'
          
      # Reference a specific commit
      - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
      # Reference the major version of a release
      - uses: actions/checkout@v4
      # Reference a specific version
      - uses: actions/checkout@v4.2.0
      # Reference a branch
      - uses: actions/checkout@main

      # Run a simple shell command
      - run: echo "Hello, GitHub Actions!"

      # Run multiple commands
      - run: |
          echo "Line 1"
          echo "Line 2"
          echo "Current directory: $(pwd)"
          echo "Files: $(ls -la)"
          echo "Node version: $NODE_VERSION"
          echo "STEP_ENV: $STEP_ENV"
          echo "step-output=Hello, World!" >> $GITHUB_OUTPUT
        # use the id to reference this step later
        id: example-step
        # The maximum time this step can run before being cancelled
        timeout-minutes: 5
        # Whether to continue running the workflow if this step fails
        continue-on-error: true
        env:
          # Step-level environment variable
          STEP_ENV: "step-value"
        # Specify the working directory for this step
        working-directory: ./scripts

      # Use the outputs from a previous step
      - run: echo "${{ steps.example-step.outputs.step-output }}"
      
      # Conditionally run a step
      # The github context contains information about the workflow run and the event that triggered the run.
      - if: ${{ github.ref == 'refs/heads/main' }}
        run: echo "Deploying to production server on branch $GITHUB_REF"

      # Create output example-output
      - name: Create output
        id: example-output
        run: echo "example-output=Hello, World!" >> $GITHUB_OUTPUT

  # Job with conditions and matrix strategy
  build-matrix:
    name: Build Matrix
    runs-on: ${{ matrix.os }}

    # Run this job only if the basic-job succeeds
    needs: basic-job

    # Run this job only on push events (not PRs)
    if: github.event_name == 'push'

    # Matrix strategy: run job multiple times with different configurations
    strategy:
      # Don't cancel other matrix jobs if one fails
      fail-fast: false
      # The maximum number of jobs to run in parallel
      max-parallel: 10
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [16, 18, 20]
        # Exclude specific combinations
        exclude:
          - os: windows-latest
            node-version: 16

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

  # Job demonstrating various GitHub Actions features
  advanced-features:
    name: Advanced Features
    runs-on: ubuntu-latest

    # Set permissions for the GITHUB_TOKEN
    permissions:
      contents: read
      pull-requests: write
      issues: write

    # Use outputs from other jobs
    needs: basic-job

    # Timeout after 10 minutes
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      # Use conditional steps
      - name: Only on main branch
        if: github.ref == 'refs/heads/main'
        run: echo "This only runs on main branch"

      # Step that continues on error
      - name: Step that might fail
        continue-on-error: true
        run: exit 1

      # Upload artifacts
      - name: Create artifact
        run: |
          mkdir -p artifacts
          echo "Build artifact" > artifacts/output.txt
          echo "Build number: ${{ github.run_number }}" >> artifacts/output.txt

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: artifacts/
          retention-days: 30

      # Set job outputs
      - name: Set outputs
        id: vars
        run: |
          echo "build-time=$(date)" >> $GITHUB_OUTPUT
          echo "commit-sha=${{ github.sha }}" >> $GITHUB_OUTPUT

      # Use step outputs
      - name: Use outputs
        run: |
          echo "Build time: ${{ steps.vars.outputs.build-time }}"
          echo "Commit SHA: ${{ steps.vars.outputs.commit-sha }}"

  # Job demonstrating services (databases, caches, etc.)
  services-example:
    name: Services Example
    runs-on: ubuntu-latest

    # Define service containers
    services:
      # PostgreSQL service
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      # Redis service
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4

      - name: Test database connection
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          PGPASSWORD=postgres psql -h localhost -p 5432 -U postgres -d testdb -c '\l'

      - name: Test Redis connection
        run: |
          sudo apt-get install -y redis-tools
          redis-cli -h localhost -p 6379 ping

  # Job for deployment (typically runs after tests pass)
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest

    # Only run on main branch and after other jobs succeed
    if: github.ref == 'refs/heads/main'
    needs: [build-matrix, advanced-features, services-example]

    # Use environment for deployment protection rules
    environment:
      name: production
      url: https://myapp.example.com

    steps:
      - uses: actions/checkout@v4

      # Download artifacts from previous jobs
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: ./artifacts

      - name: Deploy to production
        run: |
          echo "Deploying to production..."
          echo "Artifact contents:"
          cat ./artifacts/output.txt
          # Your deployment commands would go here

# Common GitHub Actions expressions and contexts:

# ${{ github.actor }}           - User who triggered the workflow
# ${{ github.event_name }}      - Event that triggered the workflow
# ${{ github.ref }}             - Git reference (branch/tag)
# ${{ github.sha }}             - Commit SHA
# ${{ github.repository }}      - Repository name (owner/repo)
# ${{ github.workspace }}       - Workspace directory path
# ${{ github.run_number }}      - Unique run number
# ${{ github.run_id }}          - Unique run ID

# ${{ env.VARIABLE_NAME }}      - Environment variable
# ${{ secrets.SECRET_NAME }}    - Repository/organization secret
# ${{ vars.VARIABLE_NAME }}     - Repository/organization variable

# ${{ steps.step-id.outputs.output-name }}  - Step output
# ${{ jobs.job-id.outputs.output-name }}    - Job output
# ${{ needs.job-id.result }}                - Job result (success, failure, cancelled, skipped)

# ${{ matrix.variable }}        - Matrix variable
# ${{ strategy.job-index }}     - Job index in matrix

# Functions available in expressions:
# ${{ contains('hello world', 'hello') }}   - true
# ${{ startsWith('hello world', 'hello') }} - true
# ${{ endsWith('hello world', 'world') }}   - true
# ${{ format('Hello {0}!', 'world') }}      - "Hello world!"
# ${{ join(array, ',') }}                   - Join array elements
# ${{ toJSON(object) }}                     - Convert to JSON string
# ${{ fromJSON(string) }}                   - Parse JSON string

# Common workflow triggers:
# on: push                      - Any push
# on: pull_request             - PR opened, synchronized, reopened
# on: release                  - Release published
# on: issues                   - Issue opened, edited, etc.
# on: workflow_dispatch        - Manual trigger
# on: repository_dispatch      - External API trigger
# on: schedule                 - Cron schedule

# Path filtering:
# on:
#   push:
#     paths: ['src/**', '!src/docs/**']  - Only changes to src/ except docs

# Common actions from the marketplace:
# actions/checkout@v4          - Checkout repository
# actions/setup-node@v4        - Setup Node.js
# actions/setup-python@v4      - Setup Python
# actions/cache@v3             - Cache dependencies
# actions/upload-artifact@v4   - Upload build artifacts
# actions/download-artifact@v4 - Download artifacts

# Creating custom actions:
# You can create JavaScript, Docker, or composite actions
# Place action.yml in the root of your action repository

# Example action.yml for a composite action:
# name: 'My Custom Action'
# description: 'A custom composite action'
# inputs:
#   input-name:
#     description: 'Input description'
#     required: true
#     default: 'default-value'
# outputs:
#   output-name:
#     description: 'Output description'
#     value: ${{ steps.step-id.outputs.value }}
# runs:
#   using: 'composite'
#   steps:
#     - run: echo "Hello ${{ inputs.input-name }}"
#       shell: bash

# Security best practices:
# - Use specific action versions (e.g., @v4, not @main)
# - Limit permissions with the 'permissions' key
# - Use environments for sensitive deployments
# - Store sensitive data in secrets, not variables
# - Use GITHUB_TOKEN instead of personal access tokens when possible
# - Review third-party actions before using them

# Workflow optimization:
# - Use caching for dependencies
# - Use matrix builds for parallel execution
# - Use artifacts to share data between jobs
# - Set appropriate timeouts
# - Use conditions to skip unnecessary work
# - Use fail-fast: false for matrix builds when appropriate

# Debugging workflows:
# - Enable debug logging with secrets.ACTIONS_STEP_DEBUG = true
# - Use 'tmate' action for SSH debugging
# - Check workflow run logs in the Actions tab
# - Use workflow_dispatch for manual testing
